import {
  derived,
  writable
} from "./chunk-E6ZP6LG5.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_style,
  space,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-RVLVW3YK.js";
import "./chunk-5WWUZCGV.js";

// node_modules/svelte-writable-derived/index.mjs
function writableDerived(origins, derive, reflect, initial) {
  var childDerivedSetter, originValues, blockNextDerive = false;
  var reflectOldValues = reflect.length >= 2;
  var wrappedDerive = (got, set, update3) => {
    childDerivedSetter = set;
    if (reflectOldValues) {
      originValues = got;
    }
    if (!blockNextDerive) {
      let returned = derive(got, set, update3);
      if (derive.length < 2) {
        set(returned);
      } else {
        return returned;
      }
    }
    blockNextDerive = false;
  };
  var childDerived = derived(origins, wrappedDerive, initial);
  var singleOrigin = !Array.isArray(origins);
  function doReflect(reflecting) {
    var setWith = reflect(reflecting, originValues);
    if (singleOrigin) {
      blockNextDerive = true;
      origins.set(setWith);
    } else {
      setWith.forEach((value, i) => {
        blockNextDerive = true;
        origins[i].set(value);
      });
    }
    blockNextDerive = false;
  }
  var tryingSet = false;
  function update2(fn) {
    var isUpdated, mutatedBySubscriptions, oldValue, newValue;
    if (tryingSet) {
      newValue = fn(get_store_value(childDerived));
      childDerivedSetter(newValue);
      return;
    }
    var unsubscribe = childDerived.subscribe((value) => {
      if (!tryingSet) {
        oldValue = value;
      } else if (!isUpdated) {
        isUpdated = true;
      } else {
        mutatedBySubscriptions = true;
      }
    });
    newValue = fn(oldValue);
    tryingSet = true;
    childDerivedSetter(newValue);
    unsubscribe();
    tryingSet = false;
    if (mutatedBySubscriptions) {
      newValue = get_store_value(childDerived);
    }
    if (isUpdated) {
      doReflect(newValue);
    }
  }
  return {
    subscribe: childDerived.subscribe,
    set(value) {
      update2(() => value);
    },
    update: update2
  };
}

// node_modules/svelte-french-toast/dist/core/store.js
var TOAST_LIMIT = 20;
var toasts = writable([]);
var pausedAt = writable(null);
var toastTimeouts = /* @__PURE__ */ new Map();
var addToRemoveQueue = (toastId) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }
  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    remove(toastId);
  }, 1e3);
  toastTimeouts.set(toastId, timeout);
};
var clearFromRemoveQueue = (toastId) => {
  const timeout = toastTimeouts.get(toastId);
  if (timeout) {
    clearTimeout(timeout);
  }
};
function update(toast2) {
  if (toast2.id) {
    clearFromRemoveQueue(toast2.id);
  }
  toasts.update(($toasts) => $toasts.map((t) => t.id === toast2.id ? { ...t, ...toast2 } : t));
}
function add(toast2) {
  toasts.update(($toasts) => [toast2, ...$toasts].slice(0, TOAST_LIMIT));
}
function upsert(toast2) {
  if (get_store_value(toasts).find((t) => t.id === toast2.id)) {
    update(toast2);
  } else {
    add(toast2);
  }
}
function dismiss(toastId) {
  toasts.update(($toasts) => {
    if (toastId) {
      addToRemoveQueue(toastId);
    } else {
      $toasts.forEach((toast2) => {
        addToRemoveQueue(toast2.id);
      });
    }
    return $toasts.map((t) => t.id === toastId || toastId === void 0 ? { ...t, visible: false } : t);
  });
}
function remove(toastId) {
  toasts.update(($toasts) => {
    if (toastId === void 0) {
      return [];
    }
    return $toasts.filter((t) => t.id !== toastId);
  });
}
function startPause(time) {
  pausedAt.set(time);
}
function endPause(time) {
  let diff;
  pausedAt.update(($pausedAt) => {
    diff = time - ($pausedAt || 0);
    return null;
  });
  toasts.update(($toasts) => $toasts.map((t) => ({
    ...t,
    pauseDuration: t.pauseDuration + diff
  })));
}
var defaultTimeouts = {
  blank: 4e3,
  error: 4e3,
  success: 2e3,
  loading: Infinity,
  custom: 4e3
};
function useToasterStore(toastOptions = {}) {
  const mergedToasts = writableDerived(toasts, ($toasts) => $toasts.map((t) => {
    var _a, _b;
    return {
      ...toastOptions,
      ...toastOptions[t.type],
      ...t,
      duration: t.duration || ((_a = toastOptions[t.type]) == null ? void 0 : _a.duration) || (toastOptions == null ? void 0 : toastOptions.duration) || defaultTimeouts[t.type],
      style: [toastOptions.style, (_b = toastOptions[t.type]) == null ? void 0 : _b.style, t.style].join(";")
    };
  }), ($toasts) => $toasts);
  return {
    toasts: mergedToasts,
    pausedAt
  };
}

// node_modules/svelte-french-toast/dist/core/types.js
var isFunction = (valOrFunction) => typeof valOrFunction === "function";
var resolveValue = (valOrFunction, arg) => isFunction(valOrFunction) ? valOrFunction(arg) : valOrFunction;

// node_modules/svelte-french-toast/dist/core/utils.js
var genId = (() => {
  let count = 0;
  return () => {
    count += 1;
    return count.toString();
  };
})();
var prefersReducedMotion = (() => {
  let shouldReduceMotion;
  return () => {
    if (shouldReduceMotion === void 0 && typeof window !== "undefined") {
      const mediaQuery = matchMedia("(prefers-reduced-motion: reduce)");
      shouldReduceMotion = !mediaQuery || mediaQuery.matches;
    }
    return shouldReduceMotion;
  };
})();

// node_modules/svelte-french-toast/dist/core/toast.js
var createToast = (message, type = "blank", opts) => ({
  createdAt: Date.now(),
  visible: true,
  type,
  ariaProps: {
    role: "status",
    "aria-live": "polite"
  },
  message,
  pauseDuration: 0,
  ...opts,
  id: (opts == null ? void 0 : opts.id) || genId()
});
var createHandler = (type) => (message, options) => {
  const toast2 = createToast(message, type, options);
  upsert(toast2);
  return toast2.id;
};
var toast = (message, opts) => createHandler("blank")(message, opts);
toast.error = createHandler("error");
toast.success = createHandler("success");
toast.loading = createHandler("loading");
toast.custom = createHandler("custom");
toast.dismiss = (toastId) => {
  dismiss(toastId);
};
toast.remove = (toastId) => remove(toastId);
toast.promise = (promise, msgs, opts) => {
  const id = toast.loading(msgs.loading, { ...opts, ...opts == null ? void 0 : opts.loading });
  promise.then((p) => {
    toast.success(resolveValue(msgs.success, p), {
      id,
      ...opts,
      ...opts == null ? void 0 : opts.success
    });
    return p;
  }).catch((e) => {
    toast.error(resolveValue(msgs.error, e), {
      id,
      ...opts,
      ...opts == null ? void 0 : opts.error
    });
  });
  return promise;
};
var toast_default = toast;

// node_modules/svelte-french-toast/dist/core/use-toaster.js
function calculateOffset(toast2, $toasts, opts) {
  const { reverseOrder, gutter = 8, defaultPosition } = opts || {};
  const relevantToasts = $toasts.filter((t) => (t.position || defaultPosition) === (toast2.position || defaultPosition) && t.height);
  const toastIndex = relevantToasts.findIndex((t) => t.id === toast2.id);
  const toastsBefore = relevantToasts.filter((toast3, i) => i < toastIndex && toast3.visible).length;
  const offset = relevantToasts.filter((t) => t.visible).slice(...reverseOrder ? [toastsBefore + 1] : [0, toastsBefore]).reduce((acc, t) => acc + (t.height || 0) + gutter, 0);
  return offset;
}
var handlers = {
  startPause() {
    startPause(Date.now());
  },
  endPause() {
    endPause(Date.now());
  },
  updateHeight: (toastId, height) => {
    update({ id: toastId, height });
  },
  calculateOffset
};
function useToaster(toastOptions) {
  const { toasts: toasts2, pausedAt: pausedAt2 } = useToasterStore(toastOptions);
  const timeouts = /* @__PURE__ */ new Map();
  let _pausedAt;
  const unsubscribes = [
    pausedAt2.subscribe(($pausedAt) => {
      if ($pausedAt) {
        for (const [, timeoutId] of timeouts) {
          clearTimeout(timeoutId);
        }
        timeouts.clear();
      }
      _pausedAt = $pausedAt;
    }),
    toasts2.subscribe(($toasts) => {
      if (_pausedAt) {
        return;
      }
      const now = Date.now();
      for (const t of $toasts) {
        if (timeouts.has(t.id)) {
          continue;
        }
        if (t.duration === Infinity) {
          continue;
        }
        const durationLeft = (t.duration || 0) + t.pauseDuration - (now - t.createdAt);
        if (durationLeft < 0) {
          if (t.visible) {
            toast_default.dismiss(t.id);
          }
          return null;
        }
        timeouts.set(t.id, setTimeout(() => toast_default.dismiss(t.id), durationLeft));
      }
    })
  ];
  onDestroy(() => {
    for (const unsubscribe of unsubscribes) {
      unsubscribe();
    }
  });
  return { toasts: toasts2, handlers };
}

// node_modules/svelte-french-toast/dist/components/CheckmarkIcon.svelte
var file = "node_modules/svelte-french-toast/dist/components/CheckmarkIcon.svelte";
function add_css(target) {
  append_styles(target, "svelte-11kvm4p", "div.svelte-11kvm4p{width:20px;opacity:0;height:20px;border-radius:10px;background:var(--primary, #61d345);position:relative;transform:rotate(45deg);animation:svelte-11kvm4p-circleAnimation 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;animation-delay:100ms}div.svelte-11kvm4p::after{content:'';box-sizing:border-box;animation:svelte-11kvm4p-checkmarkAnimation 0.2s ease-out forwards;opacity:0;animation-delay:200ms;position:absolute;border-right:2px solid;border-bottom:2px solid;border-color:var(--secondary, #fff);bottom:6px;left:6px;height:10px;width:6px}@keyframes svelte-11kvm4p-circleAnimation{from{transform:scale(0) rotate(45deg);opacity:0}to{transform:scale(1) rotate(45deg);opacity:1}}@keyframes svelte-11kvm4p-checkmarkAnimation{0%{height:0;width:0;opacity:0}40%{height:0;width:6px;opacity:1}100%{opacity:1;height:10px}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hlY2ttYXJrSWNvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBUUMsa0JBQUksQ0FDSCxLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxDQUFDLENBQ1YsTUFBTSxDQUFFLElBQUksQ0FDWixhQUFhLENBQUUsSUFBSSxDQUNuQixVQUFVLENBQUUsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLENBQ25DLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFNBQVMsQ0FBRSxPQUFPLEtBQUssQ0FBQyxDQUN4QixTQUFTLENBQUUsOEJBQWUsQ0FBQyxJQUFJLENBQUMsYUFBYSxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQ2hGLGVBQWUsQ0FBRSxLQUNsQixDQUVBLGtCQUFHLE9BQVEsQ0FDVixPQUFPLENBQUUsRUFBRSxDQUNYLFVBQVUsQ0FBRSxVQUFVLENBQ3RCLFNBQVMsQ0FBRSxpQ0FBa0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FDcEQsT0FBTyxDQUFFLENBQUMsQ0FDVixlQUFlLENBQUUsS0FBSyxDQUN0QixRQUFRLENBQUUsUUFBUSxDQUNsQixZQUFZLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FDdkIsYUFBYSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQ3hCLFlBQVksQ0FBRSxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FDcEMsTUFBTSxDQUFFLEdBQUcsQ0FDWCxJQUFJLENBQUUsR0FBRyxDQUNULE1BQU0sQ0FBRSxJQUFJLENBQ1osS0FBSyxDQUFFLEdBQ1IsQ0FFQSxXQUFXLDhCQUFnQixDQUMxQixJQUFLLENBQ0osU0FBUyxDQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsQ0FDakMsT0FBTyxDQUFFLENBQ1YsQ0FDQSxFQUFHLENBQ0YsU0FBUyxDQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsQ0FDakMsT0FBTyxDQUFFLENBQ1YsQ0FDRCxDQUVBLFdBQVcsaUNBQW1CLENBQzdCLEVBQUcsQ0FDRixNQUFNLENBQUUsQ0FBQyxDQUNULEtBQUssQ0FBRSxDQUFDLENBQ1IsT0FBTyxDQUFFLENBQ1YsQ0FDQSxHQUFJLENBQ0gsTUFBTSxDQUFFLENBQUMsQ0FDVCxLQUFLLENBQUUsR0FBRyxDQUNWLE9BQU8sQ0FBRSxDQUNWLENBQ0EsSUFBSyxDQUNKLE9BQU8sQ0FBRSxDQUFDLENBQ1YsTUFBTSxDQUFFLElBQ1QsQ0FDRCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDaGVja21hcmtJY29uLnN2ZWx0ZSJdfQ== */");
}
function create_fragment(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-11kvm4p");
      set_style(
        div,
        "--primary",
        /*primary*/
        ctx[0]
      );
      set_style(
        div,
        "--secondary",
        /*secondary*/
        ctx[1]
      );
      add_location(div, file, 5, 0, 148);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*primary*/
      1) {
        set_style(
          div,
          "--primary",
          /*primary*/
          ctx2[0]
        );
      }
      if (dirty & /*secondary*/
      2) {
        set_style(
          div,
          "--secondary",
          /*secondary*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckmarkIcon", slots, []);
  let { primary = "#61d345" } = $$props;
  let { secondary = "#fff" } = $$props;
  const writable_props = ["primary", "secondary"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CheckmarkIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("primary" in $$props2)
      $$invalidate(0, primary = $$props2.primary);
    if ("secondary" in $$props2)
      $$invalidate(1, secondary = $$props2.secondary);
  };
  $$self.$capture_state = () => ({ primary, secondary });
  $$self.$inject_state = ($$props2) => {
    if ("primary" in $$props2)
      $$invalidate(0, primary = $$props2.primary);
    if ("secondary" in $$props2)
      $$invalidate(1, secondary = $$props2.secondary);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [primary, secondary];
}
var CheckmarkIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { primary: 0, secondary: 1 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckmarkIcon",
      options,
      id: create_fragment.name
    });
  }
  get primary() {
    throw new Error("<CheckmarkIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primary(value) {
    throw new Error("<CheckmarkIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondary() {
    throw new Error("<CheckmarkIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondary(value) {
    throw new Error("<CheckmarkIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CheckmarkIcon_default = CheckmarkIcon;

// node_modules/svelte-french-toast/dist/components/ErrorIcon.svelte
var file2 = "node_modules/svelte-french-toast/dist/components/ErrorIcon.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1ee93ns", "div.svelte-1ee93ns{width:20px;opacity:0;height:20px;border-radius:10px;background:var(--primary, #ff4b4b);position:relative;transform:rotate(45deg);animation:svelte-1ee93ns-circleAnimation 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;animation-delay:100ms}div.svelte-1ee93ns::after,div.svelte-1ee93ns::before{content:'';animation:svelte-1ee93ns-firstLineAnimation 0.15s ease-out forwards;animation-delay:150ms;position:absolute;border-radius:3px;opacity:0;background:var(--secondary, #fff);bottom:9px;left:4px;height:2px;width:12px}div.svelte-1ee93ns:before{animation:svelte-1ee93ns-secondLineAnimation 0.15s ease-out forwards;animation-delay:180ms;transform:rotate(90deg)}@keyframes svelte-1ee93ns-circleAnimation{from{transform:scale(0) rotate(45deg);opacity:0}to{transform:scale(1) rotate(45deg);opacity:1}}@keyframes svelte-1ee93ns-firstLineAnimation{from{transform:scale(0);opacity:0}to{transform:scale(1);opacity:1}}@keyframes svelte-1ee93ns-secondLineAnimation{from{transform:scale(0) rotate(90deg);opacity:0}to{transform:scale(1) rotate(90deg);opacity:1}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXJyb3JJY29uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFRQyxrQkFBSSxDQUNILEtBQUssQ0FBRSxJQUFJLENBQ1gsT0FBTyxDQUFFLENBQUMsQ0FDVixNQUFNLENBQUUsSUFBSSxDQUNaLGFBQWEsQ0FBRSxJQUFJLENBQ25CLFVBQVUsQ0FBRSxJQUFJLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FDbkMsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsU0FBUyxDQUFFLE9BQU8sS0FBSyxDQUFDLENBQ3hCLFNBQVMsQ0FBRSw4QkFBZSxDQUFDLElBQUksQ0FBQyxhQUFhLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FDaEYsZUFBZSxDQUFFLEtBQ2xCLENBRUEsa0JBQUcsT0FBTyxDQUNWLGtCQUFHLFFBQVMsQ0FDWCxPQUFPLENBQUUsRUFBRSxDQUNYLFNBQVMsQ0FBRSxpQ0FBa0IsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FDckQsZUFBZSxDQUFFLEtBQUssQ0FDdEIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsT0FBTyxDQUFFLENBQUMsQ0FDVixVQUFVLENBQUUsSUFBSSxXQUFXLENBQUMsS0FBSyxDQUFDLENBQ2xDLE1BQU0sQ0FBRSxHQUFHLENBQ1gsSUFBSSxDQUFFLEdBQUcsQ0FDVCxNQUFNLENBQUUsR0FBRyxDQUNYLEtBQUssQ0FBRSxJQUNSLENBRUEsa0JBQUcsT0FBUSxDQUNWLFNBQVMsQ0FBRSxrQ0FBbUIsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FDdEQsZUFBZSxDQUFFLEtBQUssQ0FDdEIsU0FBUyxDQUFFLE9BQU8sS0FBSyxDQUN4QixDQUVBLFdBQVcsOEJBQWdCLENBQzFCLElBQUssQ0FDSixTQUFTLENBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUNqQyxPQUFPLENBQUUsQ0FDVixDQUNBLEVBQUcsQ0FDRixTQUFTLENBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUNqQyxPQUFPLENBQUUsQ0FDVixDQUNELENBRUEsV0FBVyxpQ0FBbUIsQ0FDN0IsSUFBSyxDQUNKLFNBQVMsQ0FBRSxNQUFNLENBQUMsQ0FBQyxDQUNuQixPQUFPLENBQUUsQ0FDVixDQUNBLEVBQUcsQ0FDRixTQUFTLENBQUUsTUFBTSxDQUFDLENBQUMsQ0FDbkIsT0FBTyxDQUFFLENBQ1YsQ0FDRCxDQUVBLFdBQVcsa0NBQW9CLENBQzlCLElBQUssQ0FDSixTQUFTLENBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUNqQyxPQUFPLENBQUUsQ0FDVixDQUNBLEVBQUcsQ0FDRixTQUFTLENBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUNqQyxPQUFPLENBQUUsQ0FDVixDQUNEIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkVycm9ySWNvbi5zdmVsdGUiXX0= */");
}
function create_fragment2(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-1ee93ns");
      set_style(
        div,
        "--primary",
        /*primary*/
        ctx[0]
      );
      set_style(
        div,
        "--secondary",
        /*secondary*/
        ctx[1]
      );
      add_location(div, file2, 5, 0, 148);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*primary*/
      1) {
        set_style(
          div,
          "--primary",
          /*primary*/
          ctx2[0]
        );
      }
      if (dirty & /*secondary*/
      2) {
        set_style(
          div,
          "--secondary",
          /*secondary*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ErrorIcon", slots, []);
  let { primary = "#ff4b4b" } = $$props;
  let { secondary = "#fff" } = $$props;
  const writable_props = ["primary", "secondary"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ErrorIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("primary" in $$props2)
      $$invalidate(0, primary = $$props2.primary);
    if ("secondary" in $$props2)
      $$invalidate(1, secondary = $$props2.secondary);
  };
  $$self.$capture_state = () => ({ primary, secondary });
  $$self.$inject_state = ($$props2) => {
    if ("primary" in $$props2)
      $$invalidate(0, primary = $$props2.primary);
    if ("secondary" in $$props2)
      $$invalidate(1, secondary = $$props2.secondary);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [primary, secondary];
}
var ErrorIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { primary: 0, secondary: 1 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ErrorIcon",
      options,
      id: create_fragment2.name
    });
  }
  get primary() {
    throw new Error("<ErrorIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primary(value) {
    throw new Error("<ErrorIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondary() {
    throw new Error("<ErrorIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondary(value) {
    throw new Error("<ErrorIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ErrorIcon_default = ErrorIcon;

// node_modules/svelte-french-toast/dist/components/LoaderIcon.svelte
var file3 = "node_modules/svelte-french-toast/dist/components/LoaderIcon.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1j7dflg", "div.svelte-1j7dflg{width:12px;height:12px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--secondary, #e0e0e0);border-right-color:var(--primary, #616161);animation:svelte-1j7dflg-rotate 1s linear infinite}@keyframes svelte-1j7dflg-rotate{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGVySWNvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBUUMsa0JBQUksQ0FDSCxLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLFVBQVUsQ0FDdEIsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQ2pCLGFBQWEsQ0FBRSxJQUFJLENBQ25CLFlBQVksQ0FBRSxJQUFJLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FDdkMsa0JBQWtCLENBQUUsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLENBQzNDLFNBQVMsQ0FBRSxxQkFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFDN0IsQ0FFQSxXQUFXLHFCQUFPLENBQ2pCLElBQUssQ0FDSixTQUFTLENBQUUsT0FBTyxJQUFJLENBQ3ZCLENBQ0EsRUFBRyxDQUNGLFNBQVMsQ0FBRSxPQUFPLE1BQU0sQ0FDekIsQ0FDRCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJMb2FkZXJJY29uLnN2ZWx0ZSJdfQ== */");
}
function create_fragment3(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-1j7dflg");
      set_style(
        div,
        "--primary",
        /*primary*/
        ctx[0]
      );
      set_style(
        div,
        "--secondary",
        /*secondary*/
        ctx[1]
      );
      add_location(div, file3, 5, 0, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*primary*/
      1) {
        set_style(
          div,
          "--primary",
          /*primary*/
          ctx2[0]
        );
      }
      if (dirty & /*secondary*/
      2) {
        set_style(
          div,
          "--secondary",
          /*secondary*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LoaderIcon", slots, []);
  let { primary = "#616161" } = $$props;
  let { secondary = "#e0e0e0" } = $$props;
  const writable_props = ["primary", "secondary"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LoaderIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("primary" in $$props2)
      $$invalidate(0, primary = $$props2.primary);
    if ("secondary" in $$props2)
      $$invalidate(1, secondary = $$props2.secondary);
  };
  $$self.$capture_state = () => ({ primary, secondary });
  $$self.$inject_state = ($$props2) => {
    if ("primary" in $$props2)
      $$invalidate(0, primary = $$props2.primary);
    if ("secondary" in $$props2)
      $$invalidate(1, secondary = $$props2.secondary);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [primary, secondary];
}
var LoaderIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { primary: 0, secondary: 1 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LoaderIcon",
      options,
      id: create_fragment3.name
    });
  }
  get primary() {
    throw new Error("<LoaderIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primary(value) {
    throw new Error("<LoaderIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondary() {
    throw new Error("<LoaderIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondary(value) {
    throw new Error("<LoaderIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LoaderIcon_default = LoaderIcon;

// node_modules/svelte-french-toast/dist/components/ToastIcon.svelte
var file4 = "node_modules/svelte-french-toast/dist/components/ToastIcon.svelte";
function add_css4(target) {
  append_styles(target, "svelte-1kgeier", ".indicator.svelte-1kgeier{position:relative;display:flex;justify-content:center;align-items:center;min-width:20px;min-height:20px}.status.svelte-1kgeier{position:absolute}.animated.svelte-1kgeier{position:relative;transform:scale(0.6);opacity:0.4;min-width:20px;animation:svelte-1kgeier-enter 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards}@keyframes svelte-1kgeier-enter{from{transform:scale(0.6);opacity:0.4}to{transform:scale(1);opacity:1}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9hc3RJY29uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE0QkMseUJBQVcsQ0FDVixRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFdBQVcsQ0FBRSxNQUFNLENBQ25CLFNBQVMsQ0FBRSxJQUFJLENBQ2YsVUFBVSxDQUFFLElBQ2IsQ0FFQSxzQkFBUSxDQUNQLFFBQVEsQ0FBRSxRQUNYLENBRUEsd0JBQVUsQ0FDVCxRQUFRLENBQUUsUUFBUSxDQUNsQixTQUFTLENBQUUsTUFBTSxHQUFHLENBQUMsQ0FDckIsT0FBTyxDQUFFLEdBQUcsQ0FDWixTQUFTLENBQUUsSUFBSSxDQUNmLFNBQVMsQ0FBRSxvQkFBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUNyRSxDQUVBLFdBQVcsb0JBQU0sQ0FDaEIsSUFBSyxDQUNKLFNBQVMsQ0FBRSxNQUFNLEdBQUcsQ0FBQyxDQUNyQixPQUFPLENBQUUsR0FDVixDQUNBLEVBQUcsQ0FDRixTQUFTLENBQUUsTUFBTSxDQUFDLENBQUMsQ0FDbkIsT0FBTyxDQUFFLENBQ1YsQ0FDRCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUb2FzdEljb24uc3ZlbHRlIl19 */");
}
function create_if_block_2(ctx) {
  let div;
  let loadericon;
  let t;
  let current;
  const loadericon_spread_levels = [
    /*iconTheme*/
    ctx[0]
  ];
  let loadericon_props = {};
  for (let i = 0; i < loadericon_spread_levels.length; i += 1) {
    loadericon_props = assign(loadericon_props, loadericon_spread_levels[i]);
  }
  loadericon = new LoaderIcon_default({ props: loadericon_props, $$inline: true });
  let if_block = (
    /*type*/
    ctx[2] !== "loading" && create_if_block_3(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(loadericon.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(loadericon.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "indicator svelte-1kgeier");
      add_location(div, file4, 13, 1, 390);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(loadericon, div, null);
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const loadericon_changes = dirty & /*iconTheme*/
      1 ? get_spread_update(loadericon_spread_levels, [get_spread_object(
        /*iconTheme*/
        ctx2[0]
      )]) : {};
      loadericon.$set(loadericon_changes);
      if (
        /*type*/
        ctx2[2] !== "loading"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*type*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loadericon.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(loadericon.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(loadericon);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(13:27) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*icon*/
    ctx[1]
  );
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*icon*/
      2 && switch_value !== (switch_value = /*icon*/
      ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(11:38) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*icon*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*icon*/
        ctx[1]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "animated svelte-1kgeier");
      add_location(div, file4, 9, 1, 253);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*icon*/
      2)
        set_data_dev(
          t,
          /*icon*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(9:0) {#if typeof icon === 'string'}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_4, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*type*/
      ctx2[2] === "error"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "status svelte-1kgeier");
      add_location(div, file4, 16, 3, 476);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(16:2) {#if type !== 'loading'}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let checkmarkicon;
  let current;
  const checkmarkicon_spread_levels = [
    /*iconTheme*/
    ctx[0]
  ];
  let checkmarkicon_props = {};
  for (let i = 0; i < checkmarkicon_spread_levels.length; i += 1) {
    checkmarkicon_props = assign(checkmarkicon_props, checkmarkicon_spread_levels[i]);
  }
  checkmarkicon = new CheckmarkIcon_default({
    props: checkmarkicon_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkmarkicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkmarkicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkmarkicon, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const checkmarkicon_changes = dirty & /*iconTheme*/
      1 ? get_spread_update(checkmarkicon_spread_levels, [get_spread_object(
        /*iconTheme*/
        ctx2[0]
      )]) : {};
      checkmarkicon.$set(checkmarkicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkmarkicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmarkicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkmarkicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(20:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let erroricon;
  let current;
  const erroricon_spread_levels = [
    /*iconTheme*/
    ctx[0]
  ];
  let erroricon_props = {};
  for (let i = 0; i < erroricon_spread_levels.length; i += 1) {
    erroricon_props = assign(erroricon_props, erroricon_spread_levels[i]);
  }
  erroricon = new ErrorIcon_default({ props: erroricon_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(erroricon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(erroricon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(erroricon, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const erroricon_changes = dirty & /*iconTheme*/
      1 ? get_spread_update(erroricon_spread_levels, [get_spread_object(
        /*iconTheme*/
        ctx2[0]
      )]) : {};
      erroricon.$set(erroricon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(erroricon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(erroricon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(erroricon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(18:4) {#if type === 'error'}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_if_block_1, create_if_block_2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*icon*/
    ctx2[1] === "string")
      return 0;
    if (typeof /*icon*/
    ctx2[1] !== "undefined")
      return 1;
    if (
      /*type*/
      ctx2[2] !== "blank"
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let type;
  let icon;
  let iconTheme;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastIcon", slots, []);
  let { toast: toast2 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (toast2 === void 0 && !("toast" in $$props || $$self.$$.bound[$$self.$$.props["toast"]])) {
      console.warn("<ToastIcon> was created without expected prop 'toast'");
    }
  });
  const writable_props = ["toast"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ToastIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("toast" in $$props2)
      $$invalidate(3, toast2 = $$props2.toast);
  };
  $$self.$capture_state = () => ({
    CheckmarkIcon: CheckmarkIcon_default,
    ErrorIcon: ErrorIcon_default,
    LoaderIcon: LoaderIcon_default,
    toast: toast2,
    iconTheme,
    icon,
    type
  });
  $$self.$inject_state = ($$props2) => {
    if ("toast" in $$props2)
      $$invalidate(3, toast2 = $$props2.toast);
    if ("iconTheme" in $$props2)
      $$invalidate(0, iconTheme = $$props2.iconTheme);
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
    if ("type" in $$props2)
      $$invalidate(2, type = $$props2.type);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*toast*/
    8) {
      $:
        $$invalidate(2, { type, icon, iconTheme } = toast2, type, ($$invalidate(1, icon), $$invalidate(3, toast2)), ($$invalidate(0, iconTheme), $$invalidate(3, toast2)));
    }
  };
  return [iconTheme, icon, type, toast2];
}
var ToastIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { toast: 3 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastIcon",
      options,
      id: create_fragment4.name
    });
  }
  get toast() {
    throw new Error("<ToastIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toast(value) {
    throw new Error("<ToastIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastIcon_default = ToastIcon;

// node_modules/svelte-french-toast/dist/components/ToastMessage.svelte
var file5 = "node_modules/svelte-french-toast/dist/components/ToastMessage.svelte";
function add_css5(target) {
  append_styles(target, "svelte-1nauejd", ".message.svelte-1nauejd{display:flex;justify-content:center;margin:4px 10px;color:inherit;flex:1 1 auto;white-space:pre-line}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9hc3RNZXNzYWdlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFZQyx1QkFBUyxDQUNSLE9BQU8sQ0FBRSxJQUFJLENBQ2IsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsTUFBTSxDQUFFLEdBQUcsQ0FBQyxJQUFJLENBQ2hCLEtBQUssQ0FBRSxPQUFPLENBQ2QsSUFBSSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUNkLFdBQVcsQ0FBRSxRQUNkIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlRvYXN0TWVzc2FnZS5zdmVsdGUiXX0= */");
}
function create_else_block2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*toast*/
    ctx[0].message
  );
  function switch_props(ctx2) {
    return {
      props: { toast: (
        /*toast*/
        ctx2[0]
      ) },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*toast*/
      1)
        switch_instance_changes.toast = /*toast*/
        ctx2[0];
      if (dirty & /*toast*/
      1 && switch_value !== (switch_value = /*toast*/
      ctx2[0].message)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(7:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let t_value = (
    /*toast*/
    ctx[0].message + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update2(ctx2, dirty) {
      if (dirty & /*toast*/
      1 && t_value !== (t_value = /*toast*/
      ctx2[0].message + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(5:1) {#if typeof toast.message === 'string'}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*toast*/
    ctx2[0].message === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    { class: "message" },
    /*toast*/
    ctx[0].ariaProps
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "svelte-1nauejd", true);
      add_location(div, file5, 3, 0, 37);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [{ class: "message" }, dirty & /*toast*/
      1 && /*toast*/
      ctx2[0].ariaProps]));
      toggle_class(div, "svelte-1nauejd", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastMessage", slots, []);
  let { toast: toast2 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (toast2 === void 0 && !("toast" in $$props || $$self.$$.bound[$$self.$$.props["toast"]])) {
      console.warn("<ToastMessage> was created without expected prop 'toast'");
    }
  });
  const writable_props = ["toast"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ToastMessage> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("toast" in $$props2)
      $$invalidate(0, toast2 = $$props2.toast);
  };
  $$self.$capture_state = () => ({ toast: toast2 });
  $$self.$inject_state = ($$props2) => {
    if ("toast" in $$props2)
      $$invalidate(0, toast2 = $$props2.toast);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [toast2];
}
var ToastMessage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { toast: 0 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastMessage",
      options,
      id: create_fragment5.name
    });
  }
  get toast() {
    throw new Error("<ToastMessage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toast(value) {
    throw new Error("<ToastMessage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastMessage_default = ToastMessage;

// node_modules/svelte-french-toast/dist/components/ToastBar.svelte
var file6 = "node_modules/svelte-french-toast/dist/components/ToastBar.svelte";
function add_css6(target) {
  append_styles(target, "svelte-ug60r4", "@keyframes svelte-ug60r4-enterAnimation{0%{transform:translate3d(0, calc(var(--factor) * -200%), 0) scale(0.6);opacity:0.5}100%{transform:translate3d(0, 0, 0) scale(1);opacity:1}}@keyframes svelte-ug60r4-exitAnimation{0%{transform:translate3d(0, 0, -1px) scale(1);opacity:1}100%{transform:translate3d(0, calc(var(--factor) * -150%), -1px) scale(0.6);opacity:0}}@keyframes svelte-ug60r4-fadeInAnimation{0%{opacity:0}100%{opacity:1}}@keyframes svelte-ug60r4-fadeOutAnimation{0%{opacity:1}100%{opacity:0}}.base.svelte-ug60r4{display:flex;align-items:center;background:#fff;color:#363636;line-height:1.3;will-change:transform;box-shadow:0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);max-width:350px;pointer-events:auto;padding:8px 10px;border-radius:8px}.transparent.svelte-ug60r4{opacity:0}.enter.svelte-ug60r4{animation:svelte-ug60r4-enterAnimation 0.35s cubic-bezier(0.21, 1.02, 0.73, 1) forwards}.exit.svelte-ug60r4{animation:svelte-ug60r4-exitAnimation 0.4s cubic-bezier(0.06, 0.71, 0.55, 1) forwards}.fadeIn.svelte-ug60r4{animation:svelte-ug60r4-fadeInAnimation 0.35s cubic-bezier(0.21, 1.02, 0.73, 1) forwards}.fadeOut.svelte-ug60r4{animation:svelte-ug60r4-fadeOutAnimation 0.4s cubic-bezier(0.06, 0.71, 0.55, 1) forwards}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9hc3RCYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW9DQyxXQUFXLDRCQUFlLENBQ3pCLEVBQUcsQ0FDRixTQUFTLENBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FDcEUsT0FBTyxDQUFFLEdBQ1YsQ0FDQSxJQUFLLENBQ0osU0FBUyxDQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FDeEMsT0FBTyxDQUFFLENBQ1YsQ0FDRCxDQUVBLFdBQVcsMkJBQWMsQ0FDeEIsRUFBRyxDQUNGLFNBQVMsQ0FBRSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQzNDLE9BQU8sQ0FBRSxDQUNWLENBQ0EsSUFBSyxDQUNKLFNBQVMsQ0FBRSxZQUFZLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUN2RSxPQUFPLENBQUUsQ0FDVixDQUNELENBRUEsV0FBVyw2QkFBZ0IsQ0FDMUIsRUFBRyxDQUNGLE9BQU8sQ0FBRSxDQUNWLENBQ0EsSUFBSyxDQUNKLE9BQU8sQ0FBRSxDQUNWLENBQ0QsQ0FFQSxXQUFXLDhCQUFpQixDQUMzQixFQUFHLENBQ0YsT0FBTyxDQUFFLENBQ1YsQ0FDQSxJQUFLLENBQ0osT0FBTyxDQUFFLENBQ1YsQ0FDRCxDQUVBLG1CQUFNLENBQ0wsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixVQUFVLENBQUUsSUFBSSxDQUNoQixLQUFLLENBQUUsT0FBTyxDQUNkLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLFdBQVcsQ0FBRSxTQUFTLENBQ3RCLFVBQVUsQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FDeEUsU0FBUyxDQUFFLEtBQUssQ0FDaEIsY0FBYyxDQUFFLElBQUksQ0FDcEIsT0FBTyxDQUFFLEdBQUcsQ0FBQyxJQUFJLENBQ2pCLGFBQWEsQ0FBRSxHQUNoQixDQUVBLDBCQUFhLENBQ1osT0FBTyxDQUFFLENBQ1YsQ0FFQSxvQkFBTyxDQUNOLFNBQVMsQ0FBRSw0QkFBYyxDQUFDLEtBQUssQ0FBQyxhQUFhLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQ25FLENBRUEsbUJBQU0sQ0FDTCxTQUFTLENBQUUsMkJBQWEsQ0FBQyxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUNqRSxDQUVBLHFCQUFRLENBQ1AsU0FBUyxDQUFFLDZCQUFlLENBQUMsS0FBSyxDQUFDLGFBQWEsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFDcEUsQ0FFQSxzQkFBUyxDQUNSLFNBQVMsQ0FBRSw4QkFBZ0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUNwRSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUb2FzdEJhci5zdmVsdGUiXX0= */");
}
var get_default_slot_changes = (dirty) => ({ toast: dirty & /*toast*/
1 });
var get_default_slot_context = (ctx) => ({
  ToastIcon: ToastIcon_default,
  ToastMessage: ToastMessage_default,
  toast: (
    /*toast*/
    ctx[0]
  )
});
function create_else_block3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, toast*/
        129)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*toast*/
        1)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(28:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*Component*/
    ctx[2]
  );
  function switch_props(ctx2) {
    return {
      props: {
        $$slots: {
          message: [create_message_slot],
          icon: [create_icon_slot]
        },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & /*$$scope, toast*/
      129) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & /*Component*/
      4 && switch_value !== (switch_value = /*Component*/
      ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(23:1) {#if Component}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let toasticon;
  let t;
  let toastmessage;
  let current;
  toasticon = new ToastIcon_default({
    props: { toast: (
      /*toast*/
      ctx[0]
    ) },
    $$inline: true
  });
  toastmessage = new ToastMessage_default({
    props: { toast: (
      /*toast*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toasticon.$$.fragment);
      t = space();
      create_component(toastmessage.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toasticon.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(toastmessage.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toasticon, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(toastmessage, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const toasticon_changes = {};
      if (dirty & /*toast*/
      1)
        toasticon_changes.toast = /*toast*/
        ctx2[0];
      toasticon.$set(toasticon_changes);
      const toastmessage_changes = {};
      if (dirty & /*toast*/
      1)
        toastmessage_changes.toast = /*toast*/
        ctx2[0];
      toastmessage.$set(toastmessage_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toasticon.$$.fragment, local);
      transition_in(toastmessage.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toasticon.$$.fragment, local);
      transition_out(toastmessage.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toasticon, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(toastmessage, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(29:43)     ",
    ctx
  });
  return block;
}
function create_icon_slot(ctx) {
  let toasticon;
  let current;
  toasticon = new ToastIcon_default({
    props: { toast: (
      /*toast*/
      ctx[0]
    ), slot: "icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toasticon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toasticon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toasticon, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const toasticon_changes = {};
      if (dirty & /*toast*/
      1)
        toasticon_changes.toast = /*toast*/
        ctx2[0];
      toasticon.$set(toasticon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toasticon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toasticon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toasticon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_icon_slot.name,
    type: "slot",
    source: "(25:3) ",
    ctx
  });
  return block;
}
function create_message_slot(ctx) {
  let toastmessage;
  let current;
  toastmessage = new ToastMessage_default({
    props: { toast: (
      /*toast*/
      ctx[0]
    ), slot: "message" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toastmessage.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toastmessage.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toastmessage, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const toastmessage_changes = {};
      if (dirty & /*toast*/
      1)
        toastmessage_changes.toast = /*toast*/
        ctx2[0];
      toastmessage.$set(toastmessage_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toastmessage.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toastmessage.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toastmessage, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_message_slot.name,
    type: "slot",
    source: "(26:3) ",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let div_style_value;
  let current;
  const if_block_creators = [create_if_block3, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*Component*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "base " + /*toast*/
      (ctx[0].height ? (
        /*animation*/
        ctx[4]
      ) : "transparent") + " " + /*toast*/
      (ctx[0].className || "") + " svelte-ug60r4");
      attr_dev(div, "style", div_style_value = /*style*/
      ctx[1] + "; " + /*toast*/
      ctx[0].style);
      set_style(
        div,
        "--factor",
        /*factor*/
        ctx[3]
      );
      add_location(div, file6, 17, 0, 540);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*toast, animation*/
      17 && div_class_value !== (div_class_value = "base " + /*toast*/
      (ctx2[0].height ? (
        /*animation*/
        ctx2[4]
      ) : "transparent") + " " + /*toast*/
      (ctx2[0].className || "") + " svelte-ug60r4")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*style, toast*/
      3 && div_style_value !== (div_style_value = /*style*/
      ctx2[1] + "; " + /*toast*/
      ctx2[0].style)) {
        attr_dev(div, "style", div_style_value);
      }
      const style_changed = dirty & /*style, toast*/
      3;
      if (style_changed || dirty & /*factor, style, toast*/
      11) {
        set_style(
          div,
          "--factor",
          /*factor*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastBar", slots, ["default"]);
  let { toast: toast2 } = $$props;
  let { position = void 0 } = $$props;
  let { style = "" } = $$props;
  let { Component = void 0 } = $$props;
  let factor;
  let animation;
  $$self.$$.on_mount.push(function() {
    if (toast2 === void 0 && !("toast" in $$props || $$self.$$.bound[$$self.$$.props["toast"]])) {
      console.warn("<ToastBar> was created without expected prop 'toast'");
    }
  });
  const writable_props = ["toast", "position", "style", "Component"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ToastBar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("toast" in $$props2)
      $$invalidate(0, toast2 = $$props2.toast);
    if ("position" in $$props2)
      $$invalidate(5, position = $$props2.position);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("Component" in $$props2)
      $$invalidate(2, Component = $$props2.Component);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ToastIcon: ToastIcon_default,
    prefersReducedMotion,
    ToastMessage: ToastMessage_default,
    toast: toast2,
    position,
    style,
    Component,
    factor,
    animation
  });
  $$self.$inject_state = ($$props2) => {
    if ("toast" in $$props2)
      $$invalidate(0, toast2 = $$props2.toast);
    if ("position" in $$props2)
      $$invalidate(5, position = $$props2.position);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("Component" in $$props2)
      $$invalidate(2, Component = $$props2.Component);
    if ("factor" in $$props2)
      $$invalidate(3, factor = $$props2.factor);
    if ("animation" in $$props2)
      $$invalidate(4, animation = $$props2.animation);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*toast, position*/
    33) {
      $: {
        const top = (toast2.position || position || "top-center").includes("top");
        $$invalidate(3, factor = top ? 1 : -1);
        const [enter, exit] = prefersReducedMotion() ? ["fadeIn", "fadeOut"] : ["enter", "exit"];
        $$invalidate(4, animation = toast2.visible ? enter : exit);
      }
    }
  };
  return [toast2, style, Component, factor, animation, position, slots, $$scope];
}
var ToastBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        toast: 0,
        position: 5,
        style: 1,
        Component: 2
      },
      add_css6
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastBar",
      options,
      id: create_fragment6.name
    });
  }
  get toast() {
    throw new Error("<ToastBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toast(value) {
    throw new Error("<ToastBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<ToastBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<ToastBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<ToastBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<ToastBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Component() {
    throw new Error("<ToastBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Component(value) {
    throw new Error("<ToastBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastBar_default = ToastBar;

// node_modules/svelte-french-toast/dist/components/ToastWrapper.svelte
var file7 = "node_modules/svelte-french-toast/dist/components/ToastWrapper.svelte";
function add_css7(target) {
  append_styles(target, "svelte-v01oml", ".wrapper.svelte-v01oml{left:0;right:0;display:flex;position:absolute;transform:translateY(calc(var(--offset, 16px) * var(--factor) * 1px))}.transition.svelte-v01oml{transition:all 230ms cubic-bezier(0.21, 1.02, 0.73, 1)}.active.svelte-v01oml{z-index:9999}.active.svelte-v01oml>*{pointer-events:auto}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9hc3RXcmFwcGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF5Q0Msc0JBQVMsQ0FDUixJQUFJLENBQUUsQ0FBQyxDQUNQLEtBQUssQ0FBRSxDQUFDLENBQ1IsT0FBTyxDQUFFLElBQUksQ0FDYixRQUFRLENBQUUsUUFBUSxDQUNsQixTQUFTLENBQUUsV0FBVyxLQUFLLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDdEUsQ0FFQSx5QkFBWSxDQUNYLFVBQVUsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLGFBQWEsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUN2RCxDQUVBLHFCQUFRLENBQ1AsT0FBTyxDQUFFLElBQ1YsQ0FFQSxxQkFBTyxDQUFXLENBQUcsQ0FDcEIsY0FBYyxDQUFFLElBQ2pCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlRvYXN0V3JhcHBlci5zdmVsdGUiXX0= */");
}
var get_default_slot_changes2 = (dirty) => ({ toast: dirty & /*toast*/
1 });
var get_default_slot_context2 = (ctx) => ({ toast: (
  /*toast*/
  ctx[0]
) });
function create_else_block4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context2
  );
  const default_slot_or_fallback = default_slot || fallback_block2(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update2(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, toast*/
        129)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*toast*/
        1)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(34:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let toastmessage;
  let current;
  toastmessage = new ToastMessage_default({
    props: { toast: (
      /*toast*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toastmessage.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toastmessage.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toastmessage, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const toastmessage_changes = {};
      if (dirty & /*toast*/
      1)
        toastmessage_changes.toast = /*toast*/
        ctx2[0];
      toastmessage.$set(toastmessage_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toastmessage.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toastmessage.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toastmessage, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(32:1) {#if toast.type === 'custom'}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let toastbar;
  let current;
  toastbar = new ToastBar_default({
    props: {
      toast: (
        /*toast*/
        ctx[0]
      ),
      position: (
        /*toast*/
        ctx[0].position
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toastbar.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toastbar.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toastbar, target, anchor);
      current = true;
    },
    p: function update2(ctx2, dirty) {
      const toastbar_changes = {};
      if (dirty & /*toast*/
      1)
        toastbar_changes.toast = /*toast*/
        ctx2[0];
      if (dirty & /*toast*/
      1)
        toastbar_changes.position = /*toast*/
        ctx2[0].position;
      toastbar.$set(toastbar_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toastbar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toastbar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toastbar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(35:16)     ",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block4, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*toast*/
      ctx2[0].type === "custom"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "wrapper svelte-v01oml");
      toggle_class(
        div,
        "active",
        /*toast*/
        ctx[0].visible
      );
      toggle_class(div, "transition", !prefersReducedMotion());
      set_style(
        div,
        "--factor",
        /*factor*/
        ctx[3]
      );
      set_style(
        div,
        "--offset",
        /*toast*/
        ctx[0].offset
      );
      set_style(
        div,
        "top",
        /*top*/
        ctx[5]
      );
      set_style(
        div,
        "bottom",
        /*bottom*/
        ctx[4]
      );
      set_style(
        div,
        "justify-content",
        /*justifyContent*/
        ctx[2]
      );
      add_location(div, file7, 20, 0, 667);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[9](div);
      current = true;
    },
    p: function update2(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*toast*/
      1) {
        toggle_class(
          div,
          "active",
          /*toast*/
          ctx2[0].visible
        );
      }
      if (dirty & /*factor*/
      8) {
        set_style(
          div,
          "--factor",
          /*factor*/
          ctx2[3]
        );
      }
      if (dirty & /*toast*/
      1) {
        set_style(
          div,
          "--offset",
          /*toast*/
          ctx2[0].offset
        );
      }
      if (dirty & /*top*/
      32) {
        set_style(
          div,
          "top",
          /*top*/
          ctx2[5]
        );
      }
      if (dirty & /*bottom*/
      16) {
        set_style(
          div,
          "bottom",
          /*bottom*/
          ctx2[4]
        );
      }
      if (dirty & /*justifyContent*/
      4) {
        set_style(
          div,
          "justify-content",
          /*justifyContent*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let top;
  let bottom;
  let factor;
  let justifyContent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastWrapper", slots, ["default"]);
  let { toast: toast2 } = $$props;
  let { setHeight } = $$props;
  let wrapperEl;
  onMount(() => {
    setHeight(wrapperEl.getBoundingClientRect().height);
  });
  $$self.$$.on_mount.push(function() {
    if (toast2 === void 0 && !("toast" in $$props || $$self.$$.bound[$$self.$$.props["toast"]])) {
      console.warn("<ToastWrapper> was created without expected prop 'toast'");
    }
    if (setHeight === void 0 && !("setHeight" in $$props || $$self.$$.bound[$$self.$$.props["setHeight"]])) {
      console.warn("<ToastWrapper> was created without expected prop 'setHeight'");
    }
  });
  const writable_props = ["toast", "setHeight"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ToastWrapper> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapperEl = $$value;
      $$invalidate(1, wrapperEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("toast" in $$props2)
      $$invalidate(0, toast2 = $$props2.toast);
    if ("setHeight" in $$props2)
      $$invalidate(6, setHeight = $$props2.setHeight);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    prefersReducedMotion,
    ToastBar: ToastBar_default,
    ToastMessage: ToastMessage_default,
    toast: toast2,
    setHeight,
    wrapperEl,
    justifyContent,
    factor,
    bottom,
    top
  });
  $$self.$inject_state = ($$props2) => {
    if ("toast" in $$props2)
      $$invalidate(0, toast2 = $$props2.toast);
    if ("setHeight" in $$props2)
      $$invalidate(6, setHeight = $$props2.setHeight);
    if ("wrapperEl" in $$props2)
      $$invalidate(1, wrapperEl = $$props2.wrapperEl);
    if ("justifyContent" in $$props2)
      $$invalidate(2, justifyContent = $$props2.justifyContent);
    if ("factor" in $$props2)
      $$invalidate(3, factor = $$props2.factor);
    if ("bottom" in $$props2)
      $$invalidate(4, bottom = $$props2.bottom);
    if ("top" in $$props2)
      $$invalidate(5, top = $$props2.top);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b, _c, _d, _e, _f;
    if ($$self.$$.dirty & /*toast*/
    1) {
      $:
        $$invalidate(5, top = ((_a = toast2.position) == null ? void 0 : _a.includes("top")) ? 0 : null);
    }
    if ($$self.$$.dirty & /*toast*/
    1) {
      $:
        $$invalidate(4, bottom = ((_b = toast2.position) == null ? void 0 : _b.includes("bottom")) ? 0 : null);
    }
    if ($$self.$$.dirty & /*toast*/
    1) {
      $:
        $$invalidate(3, factor = ((_c = toast2.position) == null ? void 0 : _c.includes("top")) ? 1 : -1);
    }
    if ($$self.$$.dirty & /*toast*/
    1) {
      $:
        $$invalidate(2, justifyContent = ((_d = toast2.position) == null ? void 0 : _d.includes("center")) && "center" || (((_e = toast2.position) == null ? void 0 : _e.includes("right")) || ((_f = toast2.position) == null ? void 0 : _f.includes("end"))) && "flex-end" || null);
    }
  };
  return [
    toast2,
    wrapperEl,
    justifyContent,
    factor,
    bottom,
    top,
    setHeight,
    $$scope,
    slots,
    div_binding
  ];
}
var ToastWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { toast: 0, setHeight: 6 }, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastWrapper",
      options,
      id: create_fragment7.name
    });
  }
  get toast() {
    throw new Error("<ToastWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toast(value) {
    throw new Error("<ToastWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setHeight() {
    throw new Error("<ToastWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set setHeight(value) {
    throw new Error("<ToastWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastWrapper_default = ToastWrapper;

// node_modules/svelte-french-toast/dist/components/Toaster.svelte
var file8 = "node_modules/svelte-french-toast/dist/components/Toaster.svelte";
function add_css8(target) {
  append_styles(target, "svelte-1phplh9", ".toaster.svelte-1phplh9{--default-offset:16px;position:fixed;z-index:9999;top:var(--default-offset);left:var(--default-offset);right:var(--default-offset);bottom:var(--default-offset);pointer-events:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVG9hc3Rlci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUNDLHVCQUFTLENBQ1IsZ0JBQWdCLENBQUUsSUFBSSxDQUV0QixRQUFRLENBQUUsS0FBSyxDQUNmLE9BQU8sQ0FBRSxJQUFJLENBQ2IsR0FBRyxDQUFFLElBQUksZ0JBQWdCLENBQUMsQ0FDMUIsSUFBSSxDQUFFLElBQUksZ0JBQWdCLENBQUMsQ0FDM0IsS0FBSyxDQUFFLElBQUksZ0JBQWdCLENBQUMsQ0FDNUIsTUFBTSxDQUFFLElBQUksZ0JBQWdCLENBQUMsQ0FDN0IsY0FBYyxDQUFFLElBQ2pCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlRvYXN0ZXIuc3ZlbHRlIl19 */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_each_block(key_1, ctx) {
  let first;
  let toastwrapper;
  let current;
  function func(...args) {
    return (
      /*func*/
      ctx[10](
        /*toast*/
        ctx[11],
        ...args
      )
    );
  }
  toastwrapper = new ToastWrapper_default({
    props: {
      toast: (
        /*toast*/
        ctx[11]
      ),
      setHeight: func
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(toastwrapper.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(toastwrapper.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(toastwrapper, target, anchor);
      current = true;
    },
    p: function update2(new_ctx, dirty) {
      ctx = new_ctx;
      const toastwrapper_changes = {};
      if (dirty & /*_toasts*/
      4)
        toastwrapper_changes.toast = /*toast*/
        ctx[11];
      if (dirty & /*_toasts*/
      4)
        toastwrapper_changes.setHeight = func;
      toastwrapper.$set(toastwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toastwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toastwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(toastwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(30:1) {#each _toasts as toast (toast.id)}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*_toasts*/
    ctx[2]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*toast*/
    ctx2[11].id
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true, role: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "toaster " + /*containerClassName*/
      (ctx[1] || "") + " svelte-1phplh9");
      attr_dev(
        div,
        "style",
        /*containerStyle*/
        ctx[0]
      );
      attr_dev(div, "role", "alert");
      add_location(div, file8, 22, 0, 617);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "mouseenter",
            /*handlers*/
            ctx[4].startPause,
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*handlers*/
            ctx[4].endPause,
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update2(ctx2, [dirty]) {
      if (dirty & /*_toasts, handlers*/
      20) {
        each_value = /*_toasts*/
        ctx2[2];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (!current || dirty & /*containerClassName*/
      2 && div_class_value !== (div_class_value = "toaster " + /*containerClassName*/
      (ctx2[1] || "") + " svelte-1phplh9")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*containerStyle*/
      1) {
        attr_dev(
          div,
          "style",
          /*containerStyle*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let $toasts;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toaster", slots, []);
  let { reverseOrder = false } = $$props;
  let { position = "top-center" } = $$props;
  let { toastOptions = void 0 } = $$props;
  let { gutter = 8 } = $$props;
  let { containerStyle = void 0 } = $$props;
  let { containerClassName = void 0 } = $$props;
  const { toasts: toasts2, handlers: handlers2 } = useToaster(toastOptions);
  validate_store(toasts2, "toasts");
  component_subscribe($$self, toasts2, (value) => $$invalidate(9, $toasts = value));
  let _toasts;
  const writable_props = [
    "reverseOrder",
    "position",
    "toastOptions",
    "gutter",
    "containerStyle",
    "containerClassName"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Toaster> was created with unknown prop '${key}'`);
  });
  const func = (toast2, height) => handlers2.updateHeight(toast2.id, height);
  $$self.$$set = ($$props2) => {
    if ("reverseOrder" in $$props2)
      $$invalidate(5, reverseOrder = $$props2.reverseOrder);
    if ("position" in $$props2)
      $$invalidate(6, position = $$props2.position);
    if ("toastOptions" in $$props2)
      $$invalidate(7, toastOptions = $$props2.toastOptions);
    if ("gutter" in $$props2)
      $$invalidate(8, gutter = $$props2.gutter);
    if ("containerStyle" in $$props2)
      $$invalidate(0, containerStyle = $$props2.containerStyle);
    if ("containerClassName" in $$props2)
      $$invalidate(1, containerClassName = $$props2.containerClassName);
  };
  $$self.$capture_state = () => ({
    useToaster,
    ToastWrapper: ToastWrapper_default,
    reverseOrder,
    position,
    toastOptions,
    gutter,
    containerStyle,
    containerClassName,
    toasts: toasts2,
    handlers: handlers2,
    _toasts,
    $toasts
  });
  $$self.$inject_state = ($$props2) => {
    if ("reverseOrder" in $$props2)
      $$invalidate(5, reverseOrder = $$props2.reverseOrder);
    if ("position" in $$props2)
      $$invalidate(6, position = $$props2.position);
    if ("toastOptions" in $$props2)
      $$invalidate(7, toastOptions = $$props2.toastOptions);
    if ("gutter" in $$props2)
      $$invalidate(8, gutter = $$props2.gutter);
    if ("containerStyle" in $$props2)
      $$invalidate(0, containerStyle = $$props2.containerStyle);
    if ("containerClassName" in $$props2)
      $$invalidate(1, containerClassName = $$props2.containerClassName);
    if ("_toasts" in $$props2)
      $$invalidate(2, _toasts = $$props2._toasts);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$toasts, position, reverseOrder, gutter*/
    864) {
      $:
        $$invalidate(2, _toasts = $toasts.map((toast2) => ({
          ...toast2,
          position: toast2.position || position,
          offset: handlers2.calculateOffset(toast2, $toasts, {
            reverseOrder,
            gutter,
            defaultPosition: position
          })
        })));
    }
  };
  return [
    containerStyle,
    containerClassName,
    _toasts,
    toasts2,
    handlers2,
    reverseOrder,
    position,
    toastOptions,
    gutter,
    $toasts,
    func
  ];
}
var Toaster = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        reverseOrder: 5,
        position: 6,
        toastOptions: 7,
        gutter: 8,
        containerStyle: 0,
        containerClassName: 1
      },
      add_css8
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toaster",
      options,
      id: create_fragment8.name
    });
  }
  get reverseOrder() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reverseOrder(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toastOptions() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toastOptions(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gutter() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gutter(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerStyle() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerStyle(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerClassName() {
    throw new Error("<Toaster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerClassName(value) {
    throw new Error("<Toaster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toaster_default = Toaster;

// node_modules/svelte-french-toast/dist/index.js
var dist_default = toast_default;
export {
  CheckmarkIcon_default as CheckmarkIcon,
  ErrorIcon_default as ErrorIcon,
  LoaderIcon_default as LoaderIcon,
  ToastBar_default as ToastBar,
  ToastIcon_default as ToastIcon,
  Toaster_default as Toaster,
  dist_default as default,
  resolveValue,
  toast_default as toast,
  useToaster,
  useToasterStore
};
//# sourceMappingURL=svelte-french-toast.js.map
